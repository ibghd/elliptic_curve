/*
 * 
 * Author: Ilyes Beghdadi
 * to: Snips
 * Subject: Implementing Elgamal with  elliptic curves over finite fields
 * 
 * 
 */
package ellipticCipher;

import java.math.BigInteger;
import java.util.ArrayList;

public class EllipticCipherWithOrder extends EllipticCipher {

	protected BigInteger n; // order of the element g

	public EllipticCipherWithOrder(BigInteger a, BigInteger b, BigInteger p, BigInteger[] g, BigInteger n) {
		super(a, b, p, g);
		this.n = n;
	}

	/*
	 * Algorithm to represent a message knowing the order of g in E 
	 * input:	String msg 
	 * output: 	P point representing msg 
	 * 			link between P[0] and msg
	 */
	public BigInteger[][] convertText(String msg) {
		byte[] msgbyte = msg.getBytes();
		BigInteger m = new BigInteger(msgbyte);
		int rnd = (int) (Math.random() * this.n.intValue());
		BigInteger r = new BigInteger("" + rnd);
		BigInteger[] P = this.power(this.g, r);
		BigInteger x = P[0];
		BigInteger d = m.subtract(x);
		return new BigInteger[][] { P, (new BigInteger[] { d }) };
	}

	/*
	 * Fast Exponentiation in E 
	 * inputs:	P, point of E 
	 * 			BigInteger n 
	 * output: 	nP point of E
	 */
	public BigInteger[] power(BigInteger[] P, BigInteger n) {
		BigInteger[] Q = EllipticCipherWithOrder.NeutralElement;
		String bit = n.toString(2);
		for (int i = n.bitLength() - 1; 0 <= i; i--) {
			int j = Character.getNumericValue(bit.charAt(i));
			Q = this.addition(Q, Q);
			if (j == 1) {
				Q = this.addition(Q, P);
			}
		}
		return Q;
	}
	
	public static void main(String[] args) {
		System.out.println("test fast exponentiation and EllipticCipherWithOrder algorithm");
		System.out.println("E ={(x,y)/y²=x³+2x+3 mod 263}");
		System.out.println("origin point: (200,39)");
		BigInteger a1 = new BigInteger("2");
		BigInteger b1 = new BigInteger("3");
		BigInteger p1 = new BigInteger("263");
		BigInteger n = new BigInteger("270");
		BigInteger[] g1 = new BigInteger[] { new BigInteger("200"), new BigInteger("39") };
		EllipticCipher E1 = new EllipticCipherWithOrder(a1, b1, p1, g1,n);
		System.out.println("private key: " + 5);
		BigInteger privatekey1 = new BigInteger("5");
		BigInteger[][] keys1 = E1.generateKey(new BigInteger("5"));
		System.out.println("public key: " + E1.Pt(keys1[0]) + "," + E1.Pt(keys1[1]));
		ArrayList<BigInteger[]> pts1 = E1.pointsCurve(g1);
		System.out.println("order of subgroup generated by (200,39): "+pts1.size());
		BigInteger[][] msg1 = E1.convertText("hello world");
		System.out.println("point representing plaintext: "+E1.Pt(msg1[0]));
		System.out.println("link between abcisse of Point and the plaintext: "+msg1[1][0].intValue());
		int rnd1 = (int) (Math.random() * pts1.size());
		System.out.println("random value for encryption: "+rnd1);
		BigInteger k1 = new BigInteger("" + rnd1);
		BigInteger[][] cipherText1 = E1.encryption(keys1, msg1[0], k1);
		System.out.println("ciphertext: " + E1.Pt(cipherText1[0]) + "," + E1.Pt(cipherText1[1]));
		BigInteger[] plaintext1 = E1.decryption(privatekey1, cipherText1);
		System.out.println("point decrypted: "+E1.Pt(plaintext1));
		System.out.println("plaintext: " + E1.convertText(plaintext1, msg1[1][0]));
		
	}

}
